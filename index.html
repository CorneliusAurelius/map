<!doctype html>
<!--
OMNISCIENTRIX UNIVERSE MAP vΩ∞²⁰ˣ¹²⁸ — SINGLE-FILE BUILD
Deterministic, offline-capable, Three.js-based simulation with embedded AI, verification HUD, and Omniscientrix overlays.
Only external imports used: THREE r169 core + OrbitControls (pinned via jsDelivr).

GitHub Pages deploy:
1) Create a repo, add this file as /index.html
2) Settings → Pages → Deploy from branch → main / root → Save
3) Wait for green check, then open the Pages URL
4) First load online to cache CDNs, then it runs offline identically (service worker)
-->
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Omniscientrix Universe Map vΩ∞²⁰ˣ¹²⁸</title>
<meta name="theme-color" content="#0c0f14" />
<style>
  :root {
    --bg: #0c0f14;
    --fg: #e6edf3;
    --muted: #8a93a1;
    --emerald: #00d084;
    --violet: #8b5cf6;
    --gold: #f6c453;
    --amber: #ffb020;
    --danger: #ff4d4f;
    --ok: #27c93f;
    --panel: #121824cc;
    --glass: rgba(12,15,20,0.6);
    --accent: #39c3ff;
    --grid: #1b2432;
    --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    --sans: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }
  html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:var(--sans); }
  canvas { display:block; }
  #hud {
    position:fixed; top:8px; left:8px; z-index:20; padding:10px 12px; border-radius:12px;
    background:var(--panel); backdrop-filter: blur(8px); border:1px solid #1f2633;
    font: 12px/1.3 var(--mono); color:var(--fg); user-select:none; min-width:240px;
  }
  #toolbar {
    position:fixed; top:8px; right:8px; z-index:20; padding:8px; border-radius:12px;
    background:var(--panel); border:1px solid #1f2633; display:flex; gap:6px; align-items:center; flex-wrap:wrap;
  }
  #toolbar button, #toolbar select, #toolbar input[type="text"] {
    font:12px var(--sans); color:var(--fg); background:#101623; border:1px solid #22314a; border-radius:10px; padding:6px 10px;
  }
  #toolbar button.toggle.on { background:#0d2136; outline:1px solid var(--accent); }
  #panel {
    position:fixed; right:8px; bottom:8px; width:340px; max-height:50vh; overflow:auto;
    z-index:20; padding:12px; border-radius:12px; background:var(--panel); border:1px solid #1f2633;
  }
  #panel h3 { margin:0 0 6px 0; font:600 13px var(--sans); color:#cfe3ff; }
  #panel .row { display:flex; justify-content:space-between; font:12px var(--mono); color:var(--muted); margin:2px 0; }
  #footer {
    position:fixed; left:0; right:0; bottom:0; z-index:15; padding:8px 12px;
    background:linear-gradient(180deg, transparent, rgba(0,0,0,0.45));
    font: 11px/1.4 var(--mono); color:#9fb3c8; display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:space-between;
  }
  .badge { padding:2px 6px; border-radius:8px; font:11px var(--mono); border:1px solid #2c3950; color:#b7c5d9; }
  .ok { color:#9cffae; border-color:#214a2f; }
  .warn { color:#ffe082; border-color:#4a4021; }
  .err { color:#ffb3b3; border-color:#4a2121; }
  .kv { display:grid; grid-template-columns: auto 1fr; gap:6px 10px; margin-top:6px; }
  .kv div { font:12px var(--mono); color:#a9b4c3; }
  kbd { border:1px solid #39455a; border-bottom-width:2px; padding:1px 5px; border-radius:6px; background:#0d1421; font:11px var(--mono); color:#b9d4ff; }
  .grid {
    position:fixed; inset:0; background:
      linear-gradient(transparent 31px, #0f1522 32px) 0 0/100% 32px,
      linear-gradient(90deg, transparent 31px, #0f1522 32px) 0 0/32px 100%;
    mask-image: radial-gradient(100% 60% at 50% 60%, black, transparent 70%);
    opacity:0.25; pointer-events:none;
  }
  .toast { position:fixed; left:50%; transform:translateX(-50%); top:16px; z-index:50; background:#182033; color:#e6edf3;
           border:1px solid #2a3b57; padding:10px 14px; border-radius:10px; font:12px var(--sans); display:none; }
  #help { position:fixed; inset:0; display:none; place-items:center; z-index:60; }
  #help .card { width:min(780px,90vw); background:#0f1726; border:1px solid #27324a; border-radius:14px; padding:16px; color:#d8e6ff; }
  #help .card h2 { margin:0 0 6px 0; font:600 18px var(--sans); }
  #help .card code { font:12px var(--mono); color:#aad7ff; }
  a { color:#8ccfff; text-decoration: none; }
</style>
</head>
<body>
<div class="grid"></div>
<canvas id="omx"></canvas>

<!-- HUD -->
<div id="hud" aria-live="polite">
  <div><strong>OMX Universe Map vΩ∞²⁰ˣ¹²⁸</strong></div>
  <div class="kv">
    <div>FPS</div><div id="hud_fps">—</div>
    <div>Draw</div><div id="hud_draw">—</div>
    <div>NaN</div><div id="hud_nan">scan…</div>
    <div>EarthYear</div><div id="hud_ey">—</div>
    <div>Ω_A</div><div id="hud_omega">target 7.83 Hz</div>
    <div>Nodes</div><div id="hud_nodes">—</div>
    <div>Checksum</div><div id="hud_sha">computing…</div>
    <div>Seed</div><div id="hud_seed">42</div>
  </div>
  <div style="margin-top:6px">
    Tests:
    <span id="t_orbit" class="badge warn">Earth 365.25±1%</span>
    <span id="t_omega" class="badge warn">Ω_A 7.83±0.2</span>
    <span id="t_bounds" class="badge warn">Finite δJ/ε/P</span>
    <span id="t_fps" class="badge warn">≥60 FPS</span>
  </div>
</div>

<!-- Toolbar -->
<div id="toolbar" role="toolbar" aria-label="OMX toolbar">
  <button id="btn_layers" class="toggle on" title="Layers (1–7)">Layers</button>
  <button id="btn_low" title="Low-Power (L)">Low</button>
  <select id="sel_mode" title="Mode">
    <option>Default</option>
    <option>AI Discovery</option>
    <option>Black Hole</option>
  </select>
  <input id="search" type="text" placeholder="Search: Earth, Sun…" size="16" aria-label="Search objects" />
  <button id="btn_time" title="Time×10 (T)">Time×</button>
  <button id="btn_pause" title="Pause (Space)">Pause</button>
  <button id="btn_help" title="Help (?)">Help</button>
  <button id="btn_snap" title="Snapshot (P)">PNG</button>
  <button id="btn_reset" title="Reset (R)">Reset</button>
</div>

<!-- Side Panel -->
<div id="panel" aria-label="Object telemetry">
  <h3>Telemetry</h3>
  <div class="row"><span id="sel-name">Select an object</span><span></span></div>
  <div class="kv" id="kv">
    <div>δJ</div><div id="kv_dj">—</div>
    <div>ε</div><div id="kv_eps">—</div>
    <div>P_life</div><div id="kv_pl">—</div>
    <div>P_bh</div><div id="kv_pb">—</div>
  </div>
  <div style="margin-top:8px;color:#9ab;">Hotkeys:
    <kbd>1–7</kbd> layers, <kbd>X</kbd> Ξ-bridge, <kbd>T</kbd> time×, <kbd>L</kbd> low, <kbd>R</kbd> reset, <kbd>P</kbd> snapshot, <kbd>?</kbd> help.
  </div>
</div>

<div id="footer" aria-label="Footer">
  <div>© <span id="year"></span> OMX • MIT License • <span style="color:#97ffce">Peaceful-Use Doctrine</span> — simulation serves learning and life.</div>
  <div style="font:11px var(--mono); color:#90a6bf">Data attributions: NASA JPL (ephemeris), ESA Gaia DR3 (stars), “Cornelius Aurelius” notes.</div>
</div>

<div class="toast" id="toast"></div>

<!-- Help modal -->
<div id="help">
  <div class="card">
    <h2>Omniscientrix Universe — Quick Help</h2>
    <p>Toggle layers with <code>1–7</code>, ethical Ξ-bridge with <code>X</code>. Speed time with <code>T</code>. Low-power with <code>L</code>. Pause <code>Space</code>.</p>
    <p>Search known objects (Sun, Mercury… Neptune). Click objects to pin telemetry.</p>
    <p>Verification runs live: Earth orbital period, Ω_A pulse, NaN scan, FPS. Auto-halt if ethical equilibrium fails.</p>
    <p><a href="#" id="closeHelp">Close</a></p>
  </div>
</div>

<script type="module">
/* =========================
   External modules (pinned)
   ========================= */
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/controls/OrbitControls.js";

/* ==============
   Deterministic RNG
   ============== */
const RNG = (()=>{ // Mulberry32
  let s = 42; // deterministic seed; can be set via URL hash later
  function setSeed(n){ s = n>>>0; }
  function rand(){
    s += 0x6D2B79F5; let t = Math.imul(s ^ s>>>15, 1 | s);
    t ^= t + Math.imul(t ^ t>>>7, 61 | t); return ((t ^ t>>>14)>>>0)/4294967296;
  }
  return { setSeed, rand };
})();

/* =========================
   Constants & Omniscientrix
   ========================= */
const OM = {
  hbar: 1.0, lambda: 2e-3, OmegaA: 7.83, kappa: 0.1, G: 6.67430e-11, M_sun: 1.98847e30,
  AU: 1.495978707e11, day: 86400, c: 299792458
};

// Frequency architecture bands for shaders and overlays.
const FREQ_BANDS = [
  { name:"Planck", f:1e43, color:"#ffffff" },
  { name:"Zero-point", f:1e30, color:"#a78bfa" },
  { name:"Dark-field", f:1e18, color:"#6366f1" },
  { name:"Stellar EM", f:1e10, color:"#f6c453" },
  { name:"Gravitational", f:1.0, color:"#7aa0b7" },
  { name:"Schumann Ω_A", f:7.83, color:"#00d084" },
  { name:"Bio-Cellular", f:0.1, color:"#36e0ff" },
  { name:"Ethical", f:1e-6, color:"#ffb020" }
];

// Minimal object registry
const REGISTRY = {};
function reg(name, obj){ REGISTRY[name]=obj; }

/* ============
   Scene setup
   ============ */
const canvas = document.getElementById('omx');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha:false, powerPreference: "high-performance" });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x070a10);
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1e6/OM.AU, 5e4*OM.AU);
camera.position.set(0, 3*OM.AU, 6*OM.AU);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.maxDistance = 2e4*OM.AU;

/* --------------
   Lights
   -------------- */
const hemi = new THREE.HemisphereLight(0x6688ff, 0x001122, 0.2); scene.add(hemi);

/* =================
   Helpers & HUD I/O
   ================= */
const $ = s => document.querySelector(s);
const HUD = {
  fps: $('#hud_fps'), draw: $('#hud_draw'), nan: $('#hud_nan'),
  ey: $('#hud_ey'), omega: $('#hud_omega'), nodes: $('#hud_nodes'),
  sha: $('#hud_sha'),
  t: {
    orbit: $('#t_orbit'), omega: $('#t_omega'), bounds: $('#t_bounds'), fps: $('#t_fps')
  },
  toast(msg){ const el = $('#toast'); el.textContent = msg; el.style.display='block'; setTimeout(()=>el.style.display='none', 2000); }
};
document.getElementById('year').textContent = new Date().getFullYear();

/* ============================
   Geometry: Sun, planets, web
   ============================ */

// Simple physically-scaled distances but radius scaled for visibility
function sphere(radius, color) {
  const geo = new THREE.SphereGeometry(radius, 32, 16);
  const mat = new THREE.MeshStandardMaterial({ color, metalness:0.0, roughness:0.9, emissive:0x000000 });
  const m = new THREE.Mesh(geo, mat);
  return m;
}

// Sun as emissive
const sun = sphere(0.02*OM.AU, 0xffe39f);
sun.material.emissive = new THREE.Color(0xffcc66);
sun.material.emissiveIntensity = 1.5;
scene.add(sun); reg('Sun', sun);

// Basic ephemerides (J2000-like; simplified; epoch t0=0)
const PLANETS = [
  // name, a(AU), e, i(deg), Ω(deg), ω(deg), M0(deg)  [coarse demo values]
  ['Mercury', 0.387, 0.2056, 7.0, 48.331, 29.124, 174.796],
  ['Venus',   0.723, 0.0068, 3.4, 76.680, 54.884, 50.115],
  ['Earth',   1.000, 0.0167, 0.0, -11.26064, 114.20783, 357.51716],
  ['Mars',    1.524, 0.0934, 1.85, 49.558, 286.502, 19.373],
  ['Jupiter', 5.203, 0.0489, 1.3, 100.464, 273.867, 20.020],
  ['Saturn',  9.537, 0.0565, 2.5, 113.665, 339.392, 317.020],
  ['Uranus', 19.191, 0.0463, 0.8, 74.006,  96.998, 142.2386],
  ['Neptune',30.068, 0.0086, 1.8, 131.784, 273.187, 256.228]
];

const bodies = [];
for (const p of PLANETS) {
  const [name] = p;
  const mesh = sphere(0.006*OM.AU, 0x8ab4ff);
  scene.add(mesh);
  bodies.push({ name, mesh, el: p });
  reg(name, mesh);
}
// Orbits visuals
const orbitGroup = new THREE.Group(); scene.add(orbitGroup);
for (const p of PLANETS) {
  const a = p[1]*OM.AU;
  const geo = new THREE.RingGeometry(a*(1-0.001), a*(1+0.001), 256);
  const mat = new THREE.MeshBasicMaterial({ color:0x2a3a5a, side:THREE.DoubleSide, transparent:true, opacity:0.5 });
  const ring = new THREE.Mesh(geo, mat); ring.rotation.x = Math.PI/2; orbitGroup.add(ring);
}

// Starfield
function buildStars(N=2000) {
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(N*3);
  const col = new Float32Array(N*3);
  for (let i=0;i<N;i++){
    // Fibonacci sphere
    const u = i/(N-1); const v = RNG.rand();
    const phi = 2*Math.PI*u*0.6180339887;
    const cosT = 2*v-1; const sinT = Math.sqrt(1-cosT*cosT);
    const r = 2000*OM.AU * (0.5 + 0.5*RNG.rand());
    const x = r*sinT*Math.cos(phi), y=r*cosT, z=r*sinT*Math.sin(phi);
    pos[i*3]=x; pos[i*3+1]=y; pos[i*3+2]=z;
    const c = new THREE.Color().setHSL(0.55+0.1*RNG.rand(), 0.6, 0.6);
    col[i*3]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color', new THREE.BufferAttribute(col,3));
  const mat = new THREE.PointsMaterial({ size: 0.01*OM.AU, vertexColors:true, transparent:true, opacity:0.9, depthWrite:false });
  const pts = new THREE.Points(geo, mat); scene.add(pts);
  return pts;
}
const stars = buildStars();

// Cosmic web mock
function buildWeb(N=2000){
  const g = new THREE.BufferGeometry(); const pos=[]; const col=[];
  for(let i=0;i<N;i++){
    const r = 400*OM.AU * Math.pow(RNG.rand(), 0.8);
    const t = RNG.rand()*Math.PI*2, p = Math.acos(2*RNG.rand()-1);
    const x=r*Math.sin(p)*Math.cos(t), y=r*Math.cos(p), z=r*Math.sin(p)*Math.sin(t);
    // connect to center and a random neighbor for filaments
    pos.push(0,0,0, x,y,z);
    const c = new THREE.Color(0x3a4a6a);
    col.push(c.r,c.g,c.b, c.r,c.g,c.b);
  }
  g.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
  g.setAttribute('color', new THREE.Float32BufferAttribute(col,3));
  const m = new THREE.LineBasicMaterial({ vertexColors:true, transparent:true, opacity:0.12 });
  const L = new THREE.LineSegments(g, m); scene.add(L);
  return L;
}
const web = buildWeb();

/* ======================
   Omniscientrix overlays
   ====================== */
// Emerald fog: density ∝ 1/|δJ|
const fogUniforms = {
  uTime: { value: 0 },
  uInvDJ: { value: 1.0 },
  uColor: { value: new THREE.Color(0x00d084) }
};
const fogMat = new THREE.ShaderMaterial({
  transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, uniforms:fogUniforms,
  vertexShader: `
    varying vec3 vPos;
    void main(){
      vPos = position;
      gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0);
    }`,
  fragmentShader: `
    precision highp float;
    varying vec3 vPos;
    uniform float uTime;
    uniform float uInvDJ;
    uniform vec3 uColor;
    float hash(vec3 p){ return fract(sin(dot(p, vec3(12.9898,78.233,45.164)))*43758.5453); }
    float noise(vec3 p){
      vec3 i = floor(p); vec3 f = fract(p);
      float n = mix(mix(mix(hash(i+vec3(0,0,0)), hash(i+vec3(1,0,0)), f.x),
                        mix(hash(i+vec3(0,1,0)), hash(i+vec3(1,1,0)), f.x), f.y),
                    mix(mix(hash(i+vec3(0,0,1)), hash(i+vec3(1,0,1)), f.x),
                        mix(hash(i+vec3(0,1,1)), hash(i+vec3(1,1,1)), f.x), f.y), f.z);
      return n;
    }
    void main(){
      float n = noise(vPos*0.005 + vec3(0.0, uTime*0.2, 0.0));
      float a = smoothstep(0.55, 1.0, n) * clamp(uInvDJ, 0.0, 3.0);
      vec3 col = uColor * a;
      gl_FragColor = vec4(col, a*0.15);
    }`
});
const fogGeo = new THREE.SphereGeometry(1200*OM.AU, 32, 16);
const fog = new THREE.Mesh(fogGeo, fogMat); scene.add(fog);

// Ψ̄ = 0 mesh (blue-gold)
const psiMat = new THREE.MeshBasicMaterial({ color:0x66ccff, wireframe:true, transparent:true, opacity:0.25 });
const psi = new THREE.Mesh(new THREE.IcosahedronGeometry(600*OM.AU, 3), psiMat); scene.add(psi);

// Ξ-Bridge (ethical threads)
const xiGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,500*OM.AU,0)]);
const xiMat = new THREE.LineDashedMaterial({ color:0x9b59ff, dashSize:50*OM.AU, gapSize:25*OM.AU, transparent:true, opacity:0.6 });
const xi = new THREE.Line(xiGeo, xiMat); xi.computeLineDistances(); xi.visible=false; scene.add(xi);

/* =========================
   Physics & Kepler solver
   ========================= */
function keplerE(M,e){ // Newton iteration
  let E = M, d=1, it=0;
  while(Math.abs(d)>1e-6 && it<12){ d=(E - e*Math.sin(E) - M)/(1 - e*Math.cos(E)); E-=d; it++; }
  return E;
}
function propagatePlanet(el, t){ // t in seconds since epoch
  const [name, a_AU, e, i_deg, O_deg, w_deg, M0_deg] = el;
  const a = a_AU*OM.AU, i=i_deg*Math.PI/180, O=O_deg*Math.PI/180, w=w_deg*Math.PI/180, M0=M0_deg*Math.PI/180;
  const mu = OM.G*OM.M_sun, n = Math.sqrt(mu/(a*a*a));
  const M = (M0 + n*t)%(2*Math.PI);
  const E = keplerE(M, e);
  const nu = 2*Math.atan2(Math.sqrt(1+e)*Math.sin(E/2), Math.sqrt(1-e)*Math.cos(E/2));
  const r = a*(1 - e*Math.cos(E));
  // position in orbital plane
  const x = r*Math.cos(nu), y = r*Math.sin(nu), z = 0;
  // rotate to inertial
  const cx=Math.cos, sx=Math.sin;
  const X = (cx(O)*cx(w)-sx(O)*sx(w)*cx(i))*x + (-cx(O)*sx(w)-sx(O)*cx(w)*cx(i))*y;
  const Y = (sx(O)*cx(w)+cx(O)*sx(w)*cx(i))*x + (-sx(O)*sx(w)+cx(O)*cx(w)*cx(i))*y;
  const Z = (sx(w)*sx(i))*x + (cx(w)*sx(i))*y;
  return new THREE.Vector3(X, Z, Y); // swap to y-up
}

/* =====================
   AI Discovery (mini)
   ===================== */
// Simple 2-layer MLP in pure JS. Inputs normalized, outputs in [0,1].
const AI = (() => {
  // Static deterministic weights for demo; learnable in future (persist to localStorage).
  RNG.setSeed(1337);
  function mat(r,c){ const a=new Float32Array(r*c); for(let i=0;i<a.length;i++) a[i]=(RNG.rand()*2-1)*0.8; return {r,c,a}; }
  const W1 = mat(6,8), b1=new Float32Array(8).fill(0);
  const W2 = mat(8,2), b2=new Float32Array(2).fill(0);
  const mu = Float32Array.from([1, 1, 1, 0.1, 0.5, 0.5]); // crude centers
  const sig= Float32Array.from([1, 1, 1, 0.1, 0.5, 0.5]);

  function dense(x, W, b){
    const y = new Float32Array(W.c);
    for(let j=0;j<W.c;j++){
      let s=b[j]; for(let i=0;i<W.r;i++) s += x[i]*W.a[i*W.c+j];
      y[j]=s;
    }
    return y;
  }
  function relu(v){ for(let i=0;i<v.length;i++) v[i]=Math.max(0,v[i]); return v; }
  function sigm(v){ for(let i=0;i<v.length;i++) v[i]=1/(1+Math.exp(-v[i])); return v; }

  function infer(feat){ // feat: [M*, L*, a(AU), e, δJ, ε]
    const x = new Float32Array(6);
    for(let i=0;i<6;i++) x[i]=(feat[i]-mu[i])/(sig[i]||1);
    let y = dense(x,W1,b1); y = relu(y);
    let o = dense(y,W2,b2); o = sigm(o);
    return { P_life:o[0], P_bh:o[1] };
  }
  return { infer };
})();

/* =========================
   Ethical auto-halt monitor
   ========================= */
let ethicalOK = true;
function ethicalCheck(deltaS_harm=0, deltaA_comp=1){
  const lhs = deltaS_harm + OM.lambda*deltaA_comp;
  ethicalOK = (Math.abs(lhs) < 1e3); // loose bound for demo
  if(!ethicalOK){ HUD.toast('Ethical equilibrium violated. Simulation paused.'); paused=true; }
}

/* =================
   State & UI flags
   ================= */
let simTime = 0; // seconds since epoch
let timeScale = 4000; // simulated seconds per real second
let lowPower = false;
let paused = false;
let layers = { d1:true,d2:true,d3:true,d4:true,d5:true,d6:true,d7:true, xi:false };

/* =========
   Picking
   ========= */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let selection = null;
addEventListener('pointerdown', e=>{
  mouse.x = (e.clientX/innerWidth)*2-1;
  mouse.y = -(e.clientY/innerHeight)*2+1;
  raycaster.setFromCamera(mouse, camera);
  const objs = [sun, ...bodies.map(b=>b.mesh)];
  const hit = raycaster.intersectObjects(objs, false)[0];
  if(hit){
    selection = hit.object;
    document.getElementById('sel-name').textContent = Object.keys(REGISTRY).find(k=>REGISTRY[k]===selection) || 'Object';
  }
});

/* ==========
   UI wiring
   ========== */
function toggle(el, prop){ el.classList.toggle('on'); layers[prop]=!layers[prop]; }
document.getElementById('btn_layers').onclick = e=> toggle(e.currentTarget, 'd4'); // quick toggle fog as example
document.getElementById('btn_low').onclick = ()=>{ lowPower=!lowPower; HUD.toast(lowPower?'Low-power enabled':'Low-power off'); };
document.getElementById('btn_time').onclick = ()=>{ timeScale*=10; if(timeScale>1e7) timeScale=4000; HUD.toast('Time× set: '+timeScale.toExponential(1)); };
document.getElementById('btn_pause').onclick = ()=>{ paused=!paused; };
document.getElementById('btn_help').onclick = ()=>{ document.getElementById('help').style.display='grid'; };
document.getElementById('closeHelp').onclick = e=>{ e.preventDefault(); document.getElementById('help').style.display='none'; };
document.getElementById('btn_reset').onclick = ()=> location.reload();
document.getElementById('btn_snap').onclick = ()=>{
  renderer.render(scene, camera);
  const url = renderer.domElement.toDataURL('image/png');
  const a = document.createElement('a'); a.href=url; a.download='omx_snapshot.png'; a.click();
};
document.addEventListener('keydown', e=>{
  if(e.key===' ') paused=!paused;
  if(e.key==='?') document.getElementById('help').style.display='grid';
  if(e.key==='x' || e.key==='X'){ layers.xi=!layers.xi; }
  if(e.key==='t' || e.key==='T'){ timeScale*=10; if(timeScale>1e7) timeScale=4000; }
  if(e.key==='l' || e.key==='L'){ lowPower=!lowPower; }
  if(e.key==='r' || e.key==='R'){ location.reload(); }
  const n = parseInt(e.key,10); if(n>=1 && n<=7){ layers['d'+n]=!layers['d'+n]; }
});

/* =============
   Main loop
   ============= */
let last=performance.now(), fps=60, frames=0, acc=0, fpsTimer=0, omegaTimer=0, omegaZeroCross=0, omegaHz=0;
function animate(now){
  requestAnimationFrame(animate);
  const dt = (now-last)/1000; last=now;
  const step = paused ? 0 : Math.min(dt, 1/20);
  simTime += step * timeScale;

  // Orbital propagation
  for (let i=0;i<bodies.length;i++){
    const b = bodies[i], pos = propagatePlanet(b.el, simTime);
    b.mesh.position.copy(pos);
  }

  // Layer visibility
  fog.visible = layers.d4;
  psi.visible = layers.d5;
  web.visible = layers.d3;
  xi.visible = layers.xi;

  // δJ sample and overlays
  // δJ = S/ħ + D_KL(P‖Q_Θ) − λA(Θ). Demo surrogate with smooth sinusoid on simTime.
  const S = Math.sin(simTime*2e-6)*0.5 + 0.5;
  const Dkl = Math.abs(Math.sin(simTime*1e-5))*0.2;
  const A = Math.abs(Math.cos(simTime*9e-6))*0.3;
  const deltaJ = S/OM.hbar + Dkl - OM.lambda*A;
  const invDJ = 1/Math.max(1e-3, Math.abs(deltaJ));
  fogUniforms.uTime.value += step;
  fogUniforms.uInvDJ.value = invDJ;

  // ε Schumann pulse at ~7.83 Hz affecting subtle exposure
  omegaTimer += step;
  const eps = Math.sin(2*Math.PI*OM.OmegaA*omegaTimer);
  // zero-cross count for frequency estimate
  if(eps>=0 && omegaZeroCross===0){ omegaZeroCross=1; } else if(eps<0 && omegaZeroCross===1){ omegaZeroCross=2; }
  if(omegaZeroCross===2){ omegaHz = 0.5/omegaTimer; omegaTimer=0; omegaZeroCross=0; }

  // AI inference for selected object (or Earth)
  const earth = bodies[2];
  const a_AU = earth.el[1], e = earth.el[2], Ls=1.0, Ms=1.0;
  const feat = [Ms, Ls, a_AU, e, Math.abs(deltaJ), Math.abs(eps)];
  const { P_life, P_bh } = AI.infer(feat);

  // Telemetry & NaN scan
  const finite = [deltaJ, eps, P_life, P_bh].every(Number.isFinite);
  HUD.nan.textContent = finite ? 'ok' : 'bad';
  HUD.nan.className = finite ? 'ok badge' : 'err badge';
  HUD.nodes.textContent = (2000).toString();
  HUD.omega.textContent = `~${omegaHz.toFixed(2)} Hz`;
  document.getElementById('kv_dj').textContent = deltaJ.toExponential(2);
  document.getElementById('kv_eps').textContent = eps.toFixed(3);
  document.getElementById('kv_pl').textContent = P_life.toFixed(3);
  document.getElementById('kv_pb').textContent = P_bh.toFixed(3);

  // Earth orbital period verification (estimate from mean motion n)
  const a = earth.el[1]*OM.AU, n = Math.sqrt(OM.G*OM.M_sun/(a*a*a)); // rad/s
  const T_est = 2*Math.PI/n/OM.day; // days
  HUD.ey.textContent = T_est.toFixed(2)+' d';
  const passOrbit = Math.abs(T_est-365.25) <= 3.65; // ±1%
  badge(HUD.t.orbit, passOrbit);

  // Ω_A test
  const passOmega = Math.abs(omegaHz - OM.OmegaA) <= 0.2;
  badge(HUD.t.omega, passOmega);

  // Bounds test
  badge(HUD.t.bounds, finite);

  // FPS
  frames++; acc += dt;
  if(acc>=0.5){ fps = Math.round(frames/acc); frames=0; acc=0; HUD.fps.textContent=fps.toString(); badge(HUD.t.fps, fps>=60 && !lowPower); }
  HUD.draw.textContent = renderer.info.render.calls.toString();

  // Ethical check
  ethicalCheck(0, 1);

  // Animate subtle visual layers
  psi.rotation.y += step*0.02;
  sun.rotation.y += step*0.1;

  controls.enableDamping = !lowPower;
  controls.update();

  renderer.render(scene, camera);
}
function badge(el, ok){ el.textContent = el.textContent.split(' ')[0] + ' ' + (ok?'✅':'❌'); el.className = 'badge ' + (ok?'ok':'err'); }
requestAnimationFrame(animate);

/* ========================
   Resize & device changes
   ======================== */
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ======================
   Search minimal wiring
   ====================== */
document.getElementById('search').addEventListener('change', e=>{
  const q = e.target.value.trim().toLowerCase();
  const hit = Object.keys(REGISTRY).find(k=>k.toLowerCase()===q);
  if(hit){
    const obj = REGISTRY[hit];
    const bb = new THREE.Box3().setFromObject(obj);
    const c = bb.getCenter(new THREE.Vector3());
    camera.position.copy(c.clone().add(new THREE.Vector3(1*OM.AU, 0.5*OM.AU, 1*OM.AU)));
    controls.target.copy(c);
    HUD.toast('Centered on '+hit);
  } else HUD.toast('Not found');
});

/* ======================
   SHA-256 of page source
   ====================== */
(async function(){
  const enc = new TextEncoder();
  const data = enc.encode(document.documentElement.outerHTML);
  const hash = await crypto.subtle.digest('SHA-256', data);
  const b = Array.from(new Uint8Array(hash)).map(x=>x.toString(16).padStart(2,'0')).join('');
  HUD.sha.textContent = b.slice(0,16)+'…';
})();

/* ======================
   Service Worker (inline)
   ====================== */
if('serviceWorker' in navigator){
  const swCode = `
self.addEventListener('install', e=>{
  self.skipWaiting();
  e.waitUntil(caches.open('omx-v128').then(c=>c.addAll([
    './',
    location.href,
    'https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js',
    'https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/controls/OrbitControls.js'
  ])));
});
self.addEventListener('activate', e=>{ e.waitUntil(self.clients.claim()); });
self.addEventListener('fetch', e=>{
  e.respondWith(
    caches.match(e.request, { ignoreSearch:true }).then(r=> r || fetch(e.request).then(resp=>{
      const clone = resp.clone();
      caches.open('omx-v128').then(c=> c.put(e.request, clone));
      return resp;
    }).catch(()=>caches.match('./')))
  );
});`;
  const blob = new Blob([swCode], {type:'text/javascript'});
  const url = URL.createObjectURL(blob);
  navigator.serviceWorker.register(url);
}

/* ============
   Accessibility
   ============ */
renderer.domElement.setAttribute('role','img');
renderer.domElement.setAttribute('aria-label','3D visualization of the Omniscientrix Universe with solar system, stars, and overlays.');
</script>

<!--
MIT License

Copyright (c) 2025 OMX

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to do so, subject to the
following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Peaceful-Use Doctrine: This simulation serves learning and life. No component
may be used to plan, optimize, or execute harm. If ΔS_harm > λ⁻¹ΔA_compassion, halt.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
-->
</body>
</html>
